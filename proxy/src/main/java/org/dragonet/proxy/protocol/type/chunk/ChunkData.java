/*
 * This file was automatically generated by sel-utils and
 * released under the MIT License.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/bedrock137.xml
 */
package org.dragonet.proxy.protocol.type.chunk;

import java.util.Arrays;

/**
 * Chunk's blocks, lights and other immutable data.
 */
public class ChunkData extends Stream {

	/**
	 * 16x16x16 section of the chunk. The array's keys also indicate the section's height
	 * (the 3rd element of the array will be the 3rd section from bottom, starting at `y=24`).
	 * The amount of sections should be in a range from 0 (empty chunk) to 16.
	 */
	public Section[] sections = new Section[0];
	public short[] heights = new short[256];

	/**
	 * Biomes in order `xz`.
	 */
	public byte[] biomes = new byte[256];

	/**
	 * Colums where there are world borders (in format `xz`). This feature hasn't been
	 * implemented in the game yet and crashes the client.
	 */
	public byte[] borders = new byte[0];
	public ExtraData[] extraData = new ExtraData[0];

	/**
	 * Additional data for the chunk's block entities (tiles), encoded in the same way
	 * as BlockEntityData.nbt is. The position is given by the `Int` tags `x`, `y`, `z`
	 * which are added to the block's compound tag together with the `String` tag `id`
	 * that contains the name of the tile in pascal case.
	 * Wrong encoding or missing tags may result in the block becoming invisible.
	 */
	public byte[] blockEntities = new byte[0];

	public ChunkData() {}

	public ChunkData(Section[] sections, short[] heights, byte[] biomes, byte[] borders, ExtraData[] extraData, byte[] blockEntities) {
		this.sections = sections;
		this.heights = heights;
		this.biomes = biomes;
		this.borders = borders;
		this.extraData = extraData;
		this.blockEntities = blockEntities;
	}

	@Override
	public int length() {
		int length=Buffer.varuintLength(sections.length) + Buffer.varuintLength(borders.length) + borders.length + Buffer.varuintLength(extraData.length) + blockEntities.length + 773; for(Section cvdlbm:sections){ length+=cvdlbm.length(); };for(ExtraData zhcfyr:extraData){ length+=zhcfyr.length(); } return length;
	}

	@Override
	public byte[] encode() {
		this._buffer = new byte[this.length()];
		this.writeLittleEndianByte((byte)(sections.length & 0xff)); for(Section cvdlbm:sections){ this.writeBytes(cvdlbm.encode()); }
		for(short avzhc:heights){ this.writeLittleEndianShort(avzhc); }
		this.writeBytes(biomes);
		this.writeLittleEndianByte((byte)(borders.length & 0xFF)); this.writeBytes(borders);
		this.writeVarint(extraData.length); for(ExtraData zhcfyr:extraData){ this.writeBytes(zhcfyr.encode()); }
		this.writeBytes(blockEntities);
		return this.getBuffer();
	}

	@Override
	public void decode(byte[] buffer) {
		this._buffer = buffer;
		final int _length=this.readLittleEndianByte();
		this._buffer = this.readBytes(_length);
		this._index = 0;
		int bnyrb5=this.readLittleEndianByte(); sections=new Section[bnyrb5]; for(int cvdlbm=0;cvdlbm<sections.length;cvdlbm++){ sections[cvdlbm]=new Section(); sections[cvdlbm]._index=this._index; sections[cvdlbm].decode(this._buffer); this._index=sections[cvdlbm]._index; }
		final int bhaddm=256; heights=new short[bhaddm]; for(int avzhc=0;avzhc<heights.length;avzhc++){ heights[avzhc]=readLittleEndianShort(); }
		final int bjb1c=256; biomes=this.readBytes(bjb1c);
		int bjcrcm=this.readBigEndianByte(); borders=this.readBytes(bjcrcm);
		int bvdjrfy=this.readVarint(); extraData=new ExtraData[bvdjrfy]; for(int zhcfyr=0;zhcfyr<extraData.length;zhcfyr++){ extraData[zhcfyr]=new ExtraData(); extraData[zhcfyr]._index=this._index; extraData[zhcfyr].decode(this._buffer); this._index=extraData[zhcfyr]._index; }
		blockEntities=this.readBytes(this._buffer.length-this._index);
	}

	@Override
	public String toString() {
		return "ChunkData(sections: " + Arrays.deepToString(this.sections) + ", heights: " + Arrays.toString(this.heights) + ", biomes: " + Arrays.toString(this.biomes) + ", borders: " + Arrays.toString(this.borders) + ", extraData: " + Arrays.deepToString(this.extraData) + ", blockEntities: " + Arrays.toString(this.blockEntities) + ")";
	}


}